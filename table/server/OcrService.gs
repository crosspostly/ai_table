// New/server/OcrService.gs
// KISS: простая архитектура без излишних абстракций
// DRY: единая логика обработки для всех типов источников

/**
 * Главная функция OCR обработки
 * @param {Object} request - {email, token, geminiApiKey, cellData, options}
 * @returns {Object} {ok, data: [], traceId, stats}
 */
function processOcrRequest(request) {
  var traceId = generateTraceId();
  var startTime = Date.now();
  
  try {
    // 1. Валидация входных данных
    validateOcrRequest(request);
    
    // 2. Проверка лицензии
    var licenseResult = checkLicense(request.email, request.token);
    if (!licenseResult.ok) {
      return {
        ok: false,
        error: 'LICENSE_' + (licenseResult.error || 'INVALID'),
        traceId: traceId
      };
    }
    
    // 3. Извлечение источников из ячейки
    var sources = extractSources(request.cellData, request.cellMeta || {});
    if (!sources.length) {
      return {
        ok: false,
        error: 'NO_SOURCES_FOUND',
        traceId: traceId
      };
    }
    
    logTrace(traceId, 'Sources extracted: ' + sources.length);
    
    // 4. Сбор данных из источников
    var collectionResult = collectDataFromSources(sources, request.options || {});
    
    logTrace(traceId, 'Data collected: images=' + collectionResult.images.length + 
             ', texts=' + collectionResult.texts.length);
    
    // 5. OCR обработка изображений
    var ocrResult = processImages(collectionResult.images, request.geminiApiKey, request.options || {});
    
    // 6. Объединение результатов
    var finalTexts = collectionResult.texts.concat(ocrResult.texts);\n    
    // 7. Постобработка (Markdown removal, cleanup)\n    finalTexts = finalTexts.map(function(text) {\n      return processMarkdownResponse(text);\n    });\n    \n    var processingTime = Date.now() - startTime;\n    logTrace(traceId, 'Processing completed in ' + processingTime + 'ms');\n    \n    return {\n      ok: true,\n      data: finalTexts,\n      traceId: traceId,\n      stats: {\n        sourceCount: sources.length,\n        imageCount: collectionResult.images.length,\n        textCount: collectionResult.texts.length,\n        processingTimeMs: processingTime\n      }\n    };\n    \n  } catch (error) {\n    logTrace(traceId, 'ERROR: ' + error.message);\n    return {\n      ok: false,\n      error: error.message,\n      traceId: traceId\n    };\n  }\n}\n\n/**\n * Валидация запроса\n */\nfunction validateOcrRequest(request) {\n  if (!request.email || !request.token) {\n    throw new Error('EMAIL_OR_TOKEN_MISSING');\n  }\n  \n  if (!request.geminiApiKey) {\n    throw new Error('GEMINI_API_KEY_MISSING');\n  }\n  \n  if (!request.cellData || typeof request.cellData !== 'string') {\n    throw new Error('CELL_DATA_INVALID');\n  }\n}\n\n/**\n * Сбор данных из всех источников\n */\nfunction collectDataFromSources(sources, options) {\n  var limit = Math.min(options.limit || 50, 100); // Защита от злоупотреблений\n  var images = [];\n  var texts = [];\n  var remainingCapacity = limit;\n  \n  for (var i = 0; i < sources.length && remainingCapacity > 0; i++) {\n    var source = sources[i];\n    \n    try {\n      var collector = createCollector(source.type);\n      var result = collector.collect(source, remainingCapacity);\n      \n      // Сначала добавляем тексты (они приоритетнее)\n      if (result.texts && result.texts.length) {\n        var textsToAdd = Math.min(result.texts.length, remainingCapacity);\n        texts = texts.concat(result.texts.slice(0, textsToAdd));\n        remainingCapacity -= textsToAdd;\n      }\n      \n      // Затем изображения, если есть место\n      if (result.images && result.images.length && remainingCapacity > 0) {\n        var imagesToAdd = Math.min(result.images.length, remainingCapacity);\n        images = images.concat(result.images.slice(0, imagesToAdd));\n        remainingCapacity -= imagesToAdd;\n      }\n      \n    } catch (e) {\n      // Логируем ошибку но продолжаем с другими источниками\n      console.log('Collection error for source ' + source.type + ': ' + e.message);\n    }\n  }\n  \n  return {images: images, texts: texts};\n}\n\n/**\n * OCR обработка изображений с батчированием\n */\nfunction processImages(images, geminiApiKey, options) {\n  if (!images.length) {\n    return {texts: [], errors: []};\n  }\n  \n  var chunkSize = 8; // Размер чанка для Gemini\n  var language = options.language || 'ru';\n  var texts = [];\n  var errors = [];\n  \n  // Обрабатываем изображения чанками\n  for (var i = 0; i < images.length; i += chunkSize) {\n    var chunk = images.slice(i, Math.min(i + chunkSize, images.length));\n    \n    try {\n      var chunkResult = processImageChunk(chunk, geminiApiKey, language);\n      texts = texts.concat(chunkResult);\n      \n    } catch (e) {\n      errors.push('Chunk ' + Math.floor(i/chunkSize) + ': ' + e.message);\n      \n      // Fallback: обрабатываем по одному изображению\n      for (var j = 0; j < chunk.length; j++) {\n        try {\n          var singleResult = processSingleImage(chunk[j], geminiApiKey, language);\n          if (singleResult && singleResult.trim()) {\n            texts.push(singleResult.trim());\n          }\n        } catch (e2) {\n          errors.push('Single image ' + (i + j) + ': ' + e2.message);\n        }\n      }\n    }\n  }\n  \n  return {texts: texts, errors: errors};\n}\n\n/**\n * Обработка чанка изображений через Gemini\n */\nfunction processImageChunk(images, geminiApiKey, language) {\n  var instruction = 'Транскрибируй текст на изображениях БЕЗ добавления от себя. ' +\n                   'Верни только чистый текст. Если изображений несколько — ' +\n                   'разделяй отзывы строкой из четырёх подчёркиваний: ____ ' +\n                   (language ? ('Язык: ' + language + '.') : '');\n  \n  var parts = [{text: instruction}];\n  \n  // Добавляем изображения в запрос\n  for (var i = 0; i < images.length; i++) {\n    parts.push({\n      inlineData: {\n        mimeType: images[i].mimeType,\n        data: images[i].data\n      }\n    });\n  }\n  \n  var requestBody = {\n    contents: [{parts: parts}],\n    generationConfig: {\n      maxOutputTokens: 4096,\n      temperature: 0\n    }\n  };\n  \n  var response = UrlFetchApp.fetch(\n    'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=' + geminiApiKey,\n    {\n      method: 'POST',\n      contentType: 'application/json',\n      payload: JSON.stringify(requestBody),\n      muteHttpExceptions: true\n    }\n  );\n  \n  var responseCode = response.getResponseCode();\n  var responseData = JSON.parse(response.getContentText());\n  \n  if (responseCode !== 200) {\n    var errorMsg = (responseData.error && responseData.error.message) || ('HTTP_' + responseCode);\n    throw new Error('Gemini API error: ' + errorMsg);\n  }\n  \n  var candidate = responseData.candidates && responseData.candidates[0];\n  var content = candidate && candidate.content && candidate.content.parts && candidate.content.parts[0];\n  var text = content && content.text ? content.text : '';\n  \n  // Разделяем результат по разделителю\n  return splitByDelimiter(text);\n}\n\n/**\n * Обработка одного изображения (fallback)\n */\nfunction processSingleImage(image, geminiApiKey, language) {\n  var instruction = 'Транскрибируй текст на изображении БЕЗ добавления от себя. ' +\n                   'Верни только чистый текст.' +\n                   (language ? (' Язык: ' + language + '.') : '');\n  \n  var requestBody = {\n    contents: [{\n      parts: [\n        {text: instruction},\n        {\n          inlineData: {\n            mimeType: image.mimeType,\n            data: image.data\n          }\n        }\n      ]\n    }],\n    generationConfig: {\n      maxOutputTokens: 2048,\n      temperature: 0\n    }\n  };\n  \n  var response = UrlFetchApp.fetch(\n    'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=' + geminiApiKey,\n    {\n      method: 'POST',\n      contentType: 'application/json',\n      payload: JSON.stringify(requestBody),\n      muteHttpExceptions: true\n    }\n  );\n  \n  var responseCode = response.getResponseCode();\n  var responseData = JSON.parse(response.getContentText());\n  \n  if (responseCode !== 200) {\n    var errorMsg = (responseData.error && responseData.error.message) || ('HTTP_' + responseCode);\n    throw new Error('Gemini API error: ' + errorMsg);\n  }\n  \n  var candidate = responseData.candidates && responseData.candidates[0];\n  var content = candidate && candidate.content && candidate.content.parts && candidate.content.parts[0];\n  \n  return content && content.text ? content.text : '';\n}\n\n/**\n * Разделение текста по разделителю ____\n */\nfunction splitByDelimiter(text) {\n  var cleaned = String(text || '').trim();\n  if (!cleaned) return [];\n  \n  // Основной способ: разделители ____\n  var parts = cleaned.split(/\\n?_{4,}\\n?/g)\n    .map(function(p) { return String(p || '').trim(); })\n    .filter(function(p) { return p.length > 0; });\n  \n  if (parts.length > 1) return parts;\n  \n  // Запасной способ: параграфы\n  var paragraphs = cleaned.split(/\\n{2,}/g)\n    .map(function(p) { return String(p || '').trim(); })\n    .filter(function(p) { return p.length > 0; });\n  \n  return paragraphs.length > 1 ? paragraphs : [cleaned];\n}\n\n/**\n * Постобработка Markdown (из старого кода)\n */\nfunction processMarkdownResponse(text) {\n  if (!text || typeof text !== 'string') return text;\n  \n  // Простая проверка на Markdown\n  var hasMarkdown = /\\*\\*[^*]+\\*\\*|\\*[^*]+\\*|^#{1,6}\\s+/m.test(text) ||\n                   /```[\\s\\S]*?```/.test(text) || /`[^`]+`/.test(text);\n  \n  if (!hasMarkdown) return text;\n  \n  // Конвертация Markdown в plain text\n  var cleaned = text\n    .replace(/```[\\w]*\\n?([\\s\\S]*?)\\n?```/g, function(_, code) {\n      return '\\n' + String(code || '').trim() + '\\n';\n    })\n    .replace(/`([^`]+)`/g, '$1')\n    .replace(/\\*\\*([^*]+)\\*\\*/g, function(_, content) {\n      return String(content || '').toUpperCase();\n    })\n    .replace(/\\*([^*]+)\\*/g, '$1')\n    .replace(/^#{1,6}\\s+(.+)$/gm, function(_, header) {\n      return '\\n' + String(header || '').toUpperCase() + ':\\n';\n    })\n    .replace(/\\[([^\\]]+)\\]\\([^\\)]+\\)/g, '$1')\n    .replace(/\\n{3,}/g, '\\n\\n')\n    .trim();\n  \n  return cleaned;\n}\n\n/**\n * Генерация traceId для отладки\n */\nfunction generateTraceId() {\n  var chars = 'abcdefghijklmnopqrstuvwxyz0123456789';\n  var result = '';\n  for (var i = 0; i < 8; i++) {\n    result += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  return 'ocr_' + result;\n}\n\n/**\n * Логирование с traceId\n */\nfunction logTrace(traceId, message) {\n  console.log('[' + traceId + '] ' + message);\n  \n  // Дополнительно сохраняем в кэш для серверных логов\n  try {\n    var cache = CacheService.getScriptCache();\n    var logKey = 'trace_' + traceId;\n    var existingLogs = cache.get(logKey);\n    var logs = existingLogs ? JSON.parse(existingLogs) : [];\n    \n    logs.push({\n      timestamp: new Date().toISOString(),\n      message: message\n    });\n    \n    cache.put(logKey, JSON.stringify(logs), 3600); // TTL 1 час\n  } catch (e) {\n    // Игнорируем ошибки кэширования\n  }\n}\n\n/**\n * Проверка лицензии (заглушка - нужно импортировать из основного сервера)\n */\nfunction checkLicense(email, token) {\n  // TODO: Импортировать логику из server-app/Server.gs\n  return {ok: true}; // Временная заглушка\n}